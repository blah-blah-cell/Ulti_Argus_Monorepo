# Training Data Format — DeepPacketSentinel

Generated by `scripts/generate_sample_data.py`. Output: `data/sample_flows.ndjson` (NDJSON).

## Schema

Each line is one JSON object — the `FlowFrame` from `kronos_sender.rs` with an added `label`:

| Field       | Type            | Description                                      |
|-------------|-----------------|--------------------------------------------------|
| `src_ip`    | `string`        | Source IPv4 address (dotted-decimal)             |
| `dst_ip`    | `string`        | Destination IPv4 address                         |
| `src_port`  | `int`           | Source port                                      |
| `dst_port`  | `int`           | Destination port                                 |
| `protocol`  | `string`        | `"TCP"`, `"UDP"`, or `"OTHER"`                   |
| `bytes_in`  | `int`           | Bytes received (payload_len from eBPF)           |
| `bytes_out` | `int`           | Bytes sent (0 for DPS — egress not yet tracked)  |
| `duration`  | `float`         | Flow duration in seconds                         |
| `payload`   | `string\|null`  | Base64-encoded payload bytes, or `null`          |
| `label`     | `string`        | **Training label** (not sent to live Kronos)     |

## Class Labels

| Label             | Ports / Pattern                      | Risk     |
|-------------------|--------------------------------------|----------|
| `benign`          | HTTP (80), HTTPS (443), DNS (53)     | Low      |
| `bittorrent`      | 6881–6889, `\x13BitTorrent protocol` | High     |
| `ssh_bruteforce`  | Port 22, very short duration         | High     |
| `malware_c2`      | Random high port, high entropy       | Critical |

## Generating Data

```bash
# Default: 1000 records, seed 42
python3 scripts/generate_sample_data.py

# Custom count and output
python3 scripts/generate_sample_data.py --count 10000 --out data/large_train.ndjson --seed 7
```

## Loading in Python (training pipeline)

```python
import json

records = [json.loads(line) for line in open("data/sample_flows.ndjson")]
# Each record is a dict with all fields above
# To get feature matrix + labels:
labels   = [r.pop("label") for r in records]
features = records  # remaining fields
```

## Notes

- `payload` is base64 of raw bytes as-seen by the eBPF ring buffer (max 128 bytes).
- `bytes_out` is always 0 in real DPS traffic (eBPF only sees ingress for now).
- The `label` field is **not** present in live `FlowFrame` JSON sent over IPC — it's for offline ML only.
